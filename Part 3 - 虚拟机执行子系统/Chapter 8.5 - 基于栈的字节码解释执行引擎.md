# Chapter 8.5 - 基于栈的字节码解释执行引擎

Created by : Mr Dk.

2020 / 01 / 30 23:12 🧨🧧

Ningbo, Zhejiang, China

---

## 8.5 基于栈的字节码解释执行引擎

### 8.5.1 解释执行

在 Java 初生的年代，解释执行还是比较准确的，但当主流 JVM 内部都包含了即时编译器后，Class 文件中的代码到底是被解释执行还是编译执行，就只有 JVM 自己才能判断了。

### 8.5.2 基于栈的指令集与基于寄存器的指令集

Javac 编译器输出的字节码指令流，是一种基于栈的指令集架构，指令大部分都是 **零地址指令** (没有地址)，依赖 **操作数栈** 进行工作。常用的指令级架构是基于寄存器的指令集，比如 x86 的 **二地址指令集**。

JVM 的指令通常不带参数，使用操作数栈中的数据作为输入，运算结果存储在操作数栈中。

```assembly
iconst_1
iconst_1
iadd
istore_0
```

而基于寄存器的指令包含独立的输入参数，依赖寄存器来访问和存储数据：

```assembly
mov eax, 1
add eax, 1
```

基于栈的指令集 - 优势：

- 可移植
  - 寄存器由硬件提供，程序依赖寄存器不可避免地受到体系结构的约束
  - JVM 可以由虚拟机实现自行决定把访问最频繁的数据放到寄存器中
- 代码相对紧凑
  - 一个字节
  - 没有地址参数
- 编译器实现简单
  - 不需考虑空间分配问题
  - 所需空间都在栈上操作

劣势：

- 理论执行速度较慢 (特指解释执行)
- 代码紧凑，但是实现相同功能所需的指令数量较多
- 栈的实现在内存中，对于 CPU 来说，内存是执行速度的瓶颈

JVM 会对指令的执行过程做出一系列优化以提高性能。JVM 中的 **解释器** 和 **即时编译器** 都会对输入的字节码进行优化。
